#!/usr/bin/python3

# This stage is based on coreos-assembler's `cmd-buildextend-live`. It
# builds the CoreOS Live ISO and PXE (kernel, initramfs, and rootfs)
# based on the provided metal and metal4k disk images that are provided
# as inputs.
#
# For historical context and to see git history, refer to the original source:
# https://github.com/coreos/coreos-assembler/blob/43a9c80e1f548269d71d6d586f0d5754c60f6144/src/cmd-buildextend-live

import contextlib
import glob
import hashlib
import json
import os
import re
import shutil
import struct
import subprocess
import sys
import tarfile
import tempfile

import yaml

import osbuild.api
import osbuild.remoteloop as remoteloop
from osbuild.util import checksum, osrelease
from osbuild.util.chroot import Chroot

# Size of file used to embed an Ignition config within a CPIO.
IGNITION_IMG_SIZE = 256 * 1024

# Size of the file used to embed miniso data.
MINISO_DATA_FILE_SIZE = 16 * 1024

LIVE_EXCLUDE_KARGS = set([
    '$ignition_firstboot',   # unsubstituted variable in grub config
    'console',               # no serial console by default on ISO
    'ignition.platform.id',  # we hardcode "metal"
    'ostree',                # dracut finds the tree automatically
])


# The kernel requires that uncompressed cpio archives appended to an initrd
# start on a 4-byte boundary. If there's misalignment, it stops unpacking
# and says:
#
#     Initramfs unpacking failed: invalid magic at start of compressed archive
#
# Append NUL bytes to destf until its size is a multiple of 4 bytes.
#
# https://www.kernel.org/doc/Documentation/early-userspace/buffer-format.txt
# https://github.com/torvalds/linux/blob/47ec5303/init/initramfs.c#L463
def align_initrd_for_uncompressed_append(destf):
    offset = destf.tell()
    if offset % 4:
        destf.write(b'\0' * (4 - offset % 4))


# Return OS features table for features.json, which is read by
# coreos-installer {iso|pxe} customize
def get_os_features(tree):
    features = {
        # coreos-installer >= 0.12.0
        'installer-config': True,
        # coreos/fedora-coreos-config@3edd2f28
        'live-initrd-network': True,
    }
    file = os.path.join(tree, 'usr/share/coreos-installer/example-config.yaml')
    with open(file, encoding='utf8') as f:
        example_config_yaml = yaml.safe_load(f)
    features['installer-config-directives'] = {
        k: True for k in example_config_yaml
    }
    return features


# https://www.kernel.org/doc/html/latest/admin-guide/initrd.html#compressed-cpio-images
def mkinitrd_pipe(tmproot, destf, compress=True):
    if not compress:
        align_initrd_for_uncompressed_append(destf)
    files = subprocess.check_output(['find', '.', '-mindepth', '1', '-print0'],
                                    cwd=tmproot)
    file_list = files.split(b'\0')
    # If there's a root.[squash|ero]fs, it _must_ be the first file in the cpio
    # archive, since the dracut 20live module assumes its contents are at
    # a fixed offset in the archive.
    for filename in [b'./root.squashfs', b'./root.erofs']:
        if filename in file_list:
            file_list.remove(filename)
            file_list.insert(0, filename)
            break
    cpioproc = subprocess.Popen(['cpio', '-o', '-H', 'newc', '-R', 'root:root',
                                 '--quiet', '--reproducible', '--force-local', '--null',
                                 '-D', tmproot], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    if compress:
        gzipargs = ['gzip', '-9']
    else:
        gzipargs = ['cat']
    gzipproc = subprocess.Popen(gzipargs, stdin=cpioproc.stdout, stdout=destf)
    cpioproc.stdin.write(b'\0'.join(file_list))
    cpioproc.stdin.close()
    assert cpioproc.wait() == 0, f"cpio exited with {cpioproc.returncode}"
    assert gzipproc.wait() == 0, f"gzip exited with {gzipproc.returncode}"
    # Fix up padding so the user can append the rootfs afterward
    align_initrd_for_uncompressed_append(destf)


def extend_initramfs(initramfs, tree, compress=True):
    with open(initramfs, 'ab') as fdst:
        mkinitrd_pipe(tree, fdst, compress=compress)


def cp_reflink(src, dest):
    subprocess.check_call(['cp', '--reflink=auto', src, dest])


# Make stream hash for `rdcore stream-hash`
# https://github.com/coreos/coreos-installer/blob/a8d6f50dea6e/src/bin/rdcore/stream_hash.rs#L26-L41
def make_stream_hash(src, dest):
    bufsize = 2 * 1024 * 1024
    with open(src, 'rb') as inf:
        with open(dest, 'w', encoding='utf8') as outf:
            outf.write(f'stream-hash sha256 {bufsize}\n')
            while True:
                buf = inf.read(bufsize)
                if not buf:
                    break
                outf.write(hashlib.sha256(buf).hexdigest() + '\n')


def get_os_name(tree):
    file = os.path.join(tree, 'usr/share/rpm-ostree/treefile.json')
    with open(file, encoding='utf8') as f:
        treefile = json.load(f)
    return treefile['metadata']['name']


def ensure_glob(pathname, n="", **kwargs):
    """
    Call glob.glob() and fail if there are no results or
    if the number of results doesn't match provided n
    """
    ret = glob.glob(pathname, **kwargs)
    if not ret:
        raise ValueError(f'No matches for {pathname}')
    if n != "" and len(ret) != int(n):
        raise ValueError(f'Matches for {pathname} does not match expected ({n})')
    return ret


def find_efi_vendor_dir_name(efidir):
    # Find name of vendor directory for this distro. i.e. "fedora" or "redhat".
    dirs = [n for n in os.listdir(efidir) if n != "BOOT"]
    if len(dirs) != 1:
        raise ValueError(f"did not find exactly one EFI vendor ID: {dirs}")
    vendor_id = dirs[0]
    return vendor_id


# This creates efiboot.img, which is a FAT filesystem.
def make_efi_bootfile(loop_client, input_tarball, output_efiboot_img):
    # Create the efiboot image file. Determine the size we should make
    # it by taking the tarball size and adding 2MiB for fs overhead.
    size = os.path.getsize(input_tarball) + 2 * 1024 * 1024
    with open(output_efiboot_img, "wb") as out:
        out.truncate(size)
    # Make loopback device; mkfs; populate with files
    with loop_client.device(output_efiboot_img) as loopdev:
        # On RHEL 8, when booting from a disk device (rather than a CD),
        # https://github.com/systemd/systemd/issues/14408 causes the
        # hybrid ESP to race with the ISO9660 filesystem for the
        # /dev/disk/by-label symlink unless the ESP has its own label,
        # so set EFI-SYSTEM for consistency with the metal image.
        # This should not be needed on Fedora or RHEL 9, but seems like
        # a good thing to do anyway.
        label = 'EFI-SYSTEM'
        # NOTE: the arguments to mkfs here match how virt-make-fs calls mkfs
        subprocess.check_call(['mkfs', '-t', 'vfat', '-I', '--mbr=n', '-n', label, loopdev])
        with tempfile.TemporaryDirectory() as d:
            try:
                subprocess.check_call(['mount', '-o', 'utf8', loopdev, d])
                subprocess.check_call(['tar', '-C', d, '-xf', input_tarball])
            finally:
                subprocess.check_call(['umount', d])


def parse_metal_inputs(inputs):
    def get_filepath_from_input(name):
        files = inputs[name]["data"]["files"]
        assert len(files) == 1
        filename, _ = files.popitem()
        filepath = os.path.join(inputs[name]["path"], filename)
        return filepath
    metal_file = get_filepath_from_input('metal')
    metal4k_file = get_filepath_from_input('metal4k')
    return metal_file, metal4k_file


def genisoargs_x86_64(paths):
    # Install binaries from syslinux package
    isolinuxfiles = [('/usr/share/syslinux/isolinux.bin', 0o755),
                     ('/usr/share/syslinux/ldlinux.c32', 0o755),
                     ('/usr/share/syslinux/libcom32.c32', 0o755),
                     ('/usr/share/syslinux/libutil.c32', 0o755),
                     ('/usr/share/syslinux/vesamenu.c32', 0o755)]
    for src, mode in isolinuxfiles:
        dst = os.path.join(paths["iso/isolinux"], os.path.basename(src))
        shutil.copyfile(src, dst)
        os.chmod(dst, mode)

    # for legacy bios boot AKA eltorito boot
    return ['-eltorito-boot', 'isolinux/isolinux.bin',
            '-eltorito-catalog', 'isolinux/boot.cat',
            '-no-emul-boot',
            '-boot-load-size', '4',
            '-boot-info-table']


def genisoargs_ppc64le(paths, kargs_json, volid):
    os.makedirs(os.path.join(paths["iso"], 'boot/grub'))
    # can be EFI/fedora or EFI/redhat
    grubpath = ensure_glob(os.path.join(paths["iso"], 'EFI/*/grub.cfg'), n=1)[0]
    shutil.move(grubpath, os.path.join(paths["iso"], 'boot/grub/grub.cfg'))
    for f in kargs_json['files']:
        if re.match('^EFI/.*/grub.cfg$', f['path']):
            f['path'] = 'boot/grub/grub.cfg'

    # safely remove things we don't need in the final ISO tree
    for d in ['EFI', 'isolinux']:
        shutil.rmtree(os.path.join(paths["iso"], d))

    # grub2-mkrescue is a wrapper around xorriso
    return ['grub2-mkrescue', '-volid', volid]


def genisoargs_s390x(paths, test_fixture, volid, name_version):
    # The initramfs gets referenced a lot in this function so let's
    # make a local variable for it for convenience.
    iso_initramfs = paths["iso/images/pxeboot/initrd.img"]
    # Reserve 32MB for the kernel, starting memory address of the initramfs
    # See https://github.com/weldr/lorax/blob/master/share/templates.d/99-generic/s390.tmpl
    INITRD_ADDRESS = '0x02000000'
    lorax_templates = '/usr/share/lorax/templates.d/99-generic/config_files/s390'
    shutil.copy(os.path.join(lorax_templates, 'redhat.exec'), paths["iso/images"])
    with open(os.path.join(lorax_templates, 'generic.ins'), 'r', encoding='utf8') as fp1:
        with open(os.path.join(paths["iso"], 'generic.ins'), 'w', encoding='utf8') as fp2:
            for line in fp1:
                fp2.write(line.replace('@INITRD_LOAD_ADDRESS@', INITRD_ADDRESS))
    for prmfile in [paths["iso/images/cdboot.prm"],
                    paths["iso/images/generic.prm"],
                    paths["iso/images/genericdvd.prm"]]:
        shutil.copy(paths["iso/zipl.prm"], prmfile)

    if test_fixture:
        # truncate kernel to 128k so it includes the offsets to the initrd and kargs
        # https://github.com/ibm-s390-linux/s390-tools/blob/032304d5034e/netboot/mk-s390image#L21-L24
        with open(paths["iso/images/pxeboot/vmlinuz"], 'rb+') as f:
            f.truncate(128 * 1024)
        with open(iso_initramfs, 'rb+') as f:
            f.truncate(1024)

    # On s390x, we reserve space for the Ignition config in the initrd
    # image directly since the bootloader doesn't support multiple initrds.
    # We do this by inflating the initramfs just for the duration of the
    # `mk-s390image` call.
    initramfs_size = os.stat(iso_initramfs).st_size
    # sanity-check it's 4-byte aligned (see align_initrd_for_uncompressed_append)
    assert initramfs_size % 4 == 0

    # combine kernel, initramfs and cmdline using the mk-s390image tool
    os.truncate(iso_initramfs, initramfs_size + IGNITION_IMG_SIZE)
    subprocess.check_call(['mk-s390image',
                           paths["iso/images/pxeboot/vmlinuz"],
                           paths["iso/images/cdboot.img"],
                           '-r', iso_initramfs,
                           '-p', paths["iso/images/cdboot.prm"]])
    os.truncate(iso_initramfs, initramfs_size)

    # generate .addrsize file for LPAR
    with open(paths["iso/images/initrd.addrsize"], 'wb') as addrsize:
        addrsize_data = struct.pack(">iiii", 0, int(INITRD_ADDRESS, 16), 0, initramfs_size)
        addrsize.write(addrsize_data)

    # safely remove things we don't need in the final ISO tree
    for d in ['EFI', 'isolinux']:
        shutil.rmtree(os.path.join(paths["iso"], d))

    return ['xorrisofs', '-verbose',
            '-volid', volid,
            '-volset', f"{name_version}",
            '-rational-rock', '-J', '-joliet-long',
            '-no-emul-boot', '-eltorito-boot',
            os.path.join(os.path.relpath(paths["iso/images"], paths["iso"]), 'cdboot.img')]


def gen_live_artifacts(paths, tree, filenames, deployed_tree, loop_client, version, blsentry_kargs):
    """
    Generate the ISO image.
    Based on the Lorax templates [1].
    A lot of good information can be found on the Fedora wiki [2].

    [1] https://github.com/weldr/lorax/tree/master/share/templates.d/99-generic
    [2] https://fedoraproject.org/wiki/User:Pjones/BootableCDsForBIOSAndUEFI
    """

    base_name = get_os_name(tree=deployed_tree)
    name_version = f'{base_name}-{version}'
    # The short volume ID can only be 32 characters (bytes probably). We may in
    # the future want to shorten this more intelligently, otherwise we truncate the
    # version which may impede uniqueness.
    volid = name_version[0:32]

    genisoargs = ['genisoimage', '-verbose',
                  '-V', volid,
                  '-volset', f"{name_version}",
                  # For  greater portability, consider using both
                  # Joliet and Rock Ridge extensions. Umm, OK :)
                  '-rational-rock', '-J', '-joliet-long']

    output_iso = os.path.join(tree, filenames['live-iso'])
    output_kernel = os.path.join(tree, filenames['live-kernel'])
    output_rootfs = os.path.join(tree, filenames['live-rootfs'])
    output_initramfs = os.path.join(tree, filenames['live-initramfs'])
    test_fixture = check_for_test_fixture(deployed_tree)
    basearch = os.uname().machine

    kargs_json = copy_configs_and_init_kargs_json(deployed_tree, paths, blsentry_kargs, volid)

    # Add placeholder for Ignition CPIO file.  This allows an external tool,
    # `coreos-installer iso ignition embed`, to modify an existing ISO image
    # to embed a user's custom Ignition config.  The tool wraps the Ignition
    # config in a cpio.xz and write it directly into this file in the ISO
    # image.  The cpio.xz will be read into the initramfs filesystem at
    # runtime and the Ignition Dracut module will ensure that the config is
    # moved where Ignition will see it. We only handle !s390x here since that's
    # the simple case (where layered initrds are supported). The s390x case is
    # handled lower down
    igninfo_json = {}
    if basearch != 's390x':
        with open(os.path.join(paths["iso/images"], 'ignition.img'), 'wb') as fdst:
            fdst.write(bytes(IGNITION_IMG_SIZE))
        igninfo_json = {'file': 'images/ignition.img'}

    # For x86_64 legacy boot (BIOS) booting
    if basearch == "x86_64":
        genisoargs += genisoargs_x86_64(paths)
    elif basearch == "ppc64le":
        genisoargs = genisoargs_ppc64le(paths, kargs_json, volid)
    elif basearch == "s390x":
        genisoargs = genisoargs_s390x(paths, test_fixture, volid, name_version)
        update_image_offsets_s390x(paths, kargs_json, igninfo_json)

    # Drop zipl.prm as it was either unused (!s390x) or is now no longer
    # needed (s390x)
    os.unlink(paths["iso/zipl.prm"])

    # For x86_64 and aarch64 UEFI booting
    if basearch in ("x86_64", "aarch64"):
        efiboot_path = mkefiboot(paths, deployed_tree, volid, loop_client)
        genisoargs += ['-eltorito-alt-boot', '-efi-boot', efiboot_path, '-no-emul-boot']

    # We've done everything that might affect kargs, so filter out any files
    # that no longer exist and write out the kargs JSON if it lists any files
    kargs_json['files'] = [f for f in kargs_json['files']
                           if os.path.exists(os.path.join(paths["iso"], f['path']))]
    kargs_json['files'].sort(key=lambda f: f['path'])
    if kargs_json['files']:
        # Store the location of "karg embed areas" for use by
        # `coreos-installer iso kargs modify`
        with open(paths["iso/coreos/kargs.json"], 'w', encoding='utf8') as fh:
            json.dump(kargs_json, fh, indent=2, sort_keys=True)
            fh.write('\n')

    # Write out the igninfo.json file. This is used by coreos-installer to know
    # how to embed the Ignition config.
    with open(paths["iso/coreos/igninfo.json"], 'w', encoding='utf8') as fh:
        json.dump(igninfo_json, fh, indent=2, sort_keys=True)
        fh.write('\n')

    # Define inputs and outputs
    genisoargs_final = genisoargs + ['-o', paths["live.iso"], paths["iso"]]

    with open(paths["iso/coreos/miniso.dat"], 'wb') as f:
        f.truncate(MINISO_DATA_FILE_SIZE)

    if test_fixture:
        trim_for_test_fixtures(paths)

    subprocess.check_call(genisoargs_final)

    # Add MBR, and GPT with ESP, for x86_64 BIOS/UEFI boot when ISO is
    # copied to a USB stick
    if basearch == "x86_64":
        subprocess.check_call(['isohybrid', '--uefi', paths["live.iso"]])

    # Copy to final output locations the things that won't change from
    # this point forward. We do it here because we unlink the the rootfs below.
    cp_reflink(paths["iso/images/pxeboot/vmlinuz"], output_kernel)
    cp_reflink(paths["iso/images/pxeboot/initrd.img"], output_initramfs)
    cp_reflink(paths["iso/images/pxeboot/rootfs.img"], output_rootfs)

    # Here we generate a minimal ISO purely for the purpose of
    # calculating some data such that, given the full live ISO in
    # future, coreos-installer can regenerate a minimal ISO.
    #
    # We first generate the minimal ISO and then call coreos-installer
    # pack with both the minimal and full ISO as arguments. This will
    # delete the minimal ISO (i.e. --consume) and update in place the
    # full Live ISO.
    #
    # The only difference in the minimal ISO is that we drop two files.
    # We keep everything else the same to maximize file matching between
    # the two versions so we can get the smallest delta. E.g. we keep the
    # `coreos.liveiso` karg, even though the miniso doesn't need it.
    # coreos-installer takes care of removing it.
    os.unlink(paths["iso/images/pxeboot/rootfs.img"])
    os.unlink(paths["iso/coreos/miniso.dat"])
    subprocess.check_call(genisoargs + ['-o', paths["live.iso.minimal"], paths["iso"]])
    if basearch == "x86_64":
        subprocess.check_call(['isohybrid', '--uefi', paths["live.iso.minimal"]])
    with Chroot(deployed_tree, bind_mounts=["/run"]) as chroot:
        chroot.run(['coreos-installer', 'pack', 'minimal-iso', paths["live.iso"],
                   paths["live.iso.minimal"], '--consume'], check=True)

    # Finally we can copy the ISO to the final output location
    cp_reflink(paths["live.iso"], output_iso)


def update_image_offsets_s390x(paths, kargs_json, igninfo_json):
    # Get the kargs and initramfs offsets in the cdboot.img. For more info, see:
    # https://github.com/ibm-s390-linux/s390-tools/blob/032304d5034e/netboot/mk-s390image#L21-L23
    CDBOOT_IMG_OFFS_INITRD_START_BYTES = 66568
    CDBOOT_IMG_OFFS_KARGS_START_BYTES = 66688
    CDBOOT_IMG_OFFS_KARGS_MAX_SIZE = 896

    iso_initramfs = paths["iso/images/pxeboot/initrd.img"]
    with open(paths["iso/images/cdboot.img"], 'rb') as f:
        f.seek(CDBOOT_IMG_OFFS_INITRD_START_BYTES)
        offset = struct.unpack(">Q", f.read(8))[0]

        # sanity-check we're at the right spot by comparing a few bytes
        f.seek(offset)
        with open(iso_initramfs, 'rb') as canonical:
            if f.read(1024) != canonical.read(1024):
                raise ValueError(f"expected initrd at offset {offset}")

        # kargs are part of 'images/cdboot.img' blob
        kargs_json['files'].append({
            'path': 'images/cdboot.img',
            'offset': CDBOOT_IMG_OFFS_KARGS_START_BYTES,
            'pad': '\0',
            'end': '\0',
        })
        kargs_json.update(
            size=CDBOOT_IMG_OFFS_KARGS_MAX_SIZE,
        )

    igninfo_json.update({
        'file': 'images/cdboot.img',
        'offset': offset + os.stat(iso_initramfs).st_size,
        'length': IGNITION_IMG_SIZE,
    })


def mkefiboot(paths, deployed_tree, volid, loop_client):
    """
    Creates an efi boot image (efiboot.img) file, required for EFI
    booting the ISO. This is a fat32 formatted filesystem that contains
    all the files needed for EFI boot from an ISO.

    Returns the path to the image file.
    """
    # In restrictive environments, setgid, setuid and ownership changes
    # may be restricted. This sets the file ownership to root and
    # removes the setgid and setuid bits in the tarball.
    def strip(tarinfo):
        tarinfo.uid = 0
        tarinfo.gid = 0
        if tarinfo.isdir():
            tarinfo.mode = 0o755
        elif tarinfo.isfile():
            tarinfo.mode = 0o0644
        return tarinfo

    efidir = paths["efi"]
    shutil.copytree(os.path.join(deployed_tree, 'usr/lib/bootupd/updates/EFI'), efidir)
    vendor_id = find_efi_vendor_dir_name(efidir)

    # Delete fallback and its CSV file.  Its purpose is to create
    # EFI boot variables, which we don't want when booting from
    # removable media.
    #
    # A future shim release will merge fallback.efi into the main
    # shim binary and enable the fallback behavior when the CSV
    # exists.  But for now, fail if fallback.efi is missing.
    for path in ensure_glob(os.path.join(efidir, "BOOT", "fb*.efi")):
        os.unlink(path)
    for path in ensure_glob(os.path.join(efidir, vendor_id, "BOOT*.CSV")):
        os.unlink(path)

    # Drop vendor copies of shim; we already have it in BOOT*.EFI in
    # BOOT
    for path in ensure_glob(os.path.join(efidir, vendor_id, "shim*.efi")):
        os.unlink(path)

    # Consolidate remaining files into BOOT.  shim needs GRUB to be
    # there, and the rest doesn't hurt.
    for path in ensure_glob(os.path.join(efidir, vendor_id, "*")):
        shutil.move(path, os.path.join(efidir, "BOOT"))
    os.rmdir(os.path.join(efidir, vendor_id))

    # Inject a stub grub.cfg pointing to the one in the main ISO image.
    #
    # When booting via El Torito, this stub is not used; GRUB reads
    # the ISO image directly using its own ISO support.  This
    # happens when booting from a CD device, or when the ISO is
    # copied to a USB stick and booted on EFI firmware which prefers
    # to boot a hard disk from an El Torito image if it has one.
    # EDK II in QEMU behaves this way.
    #
    # This stub is used with EFI firmware which prefers to boot a
    # hard disk from an ESP, or which cannot boot a hard disk via El
    # Torito at all.  In that case, GRUB thinks it booted from a
    # partition of the disk (a fake ESP created by isohybrid,
    # pointing to efiboot.img) and needs a grub.cfg there.
    with open(os.path.join(efidir, "BOOT", "grub.cfg"), "w", encoding='utf8') as fh:
        fh.write(f'''search --label "{volid}" --set root --no-floppy
set prefix=($root)/EFI/{vendor_id}
echo "Booting via ESP..."
configfile $prefix/grub.cfg
boot
''')

    # Install binaries from boot partition
    # Manually construct the tarball to ensure proper permissions and ownership
    efitarfile = tempfile.NamedTemporaryFile(suffix=".tar")
    with tarfile.open(efitarfile.name, "w:", dereference=True) as tar:
        tar.add(efidir, arcname="/EFI", filter=strip)

    # Create the efiboot.img file in the images/ dir
    efibootfile = paths["iso/images/efiboot.img"]
    make_efi_bootfile(loop_client, input_tarball=efitarfile.name, output_efiboot_img=efibootfile)
    return "images/efiboot.img"


def mkrootfs_metal(paths, workdir, img_metal, fstype, fsoptions, loop_client):
    """
    Mounts a copy of the metal image and modifies it accordingly to create a (fstype) rootfs from its contents for the
    live ISO. fstype must be squashfs or erofs.

    Returns the bls entry kernel arguments for the ISO bootloader.
    """
    basearch = os.uname().machine
    tmp_rootfs_dir = os.path.join(workdir, 'tmp-rootfs-dir')
    os.mkdir(tmp_rootfs_dir)

    # Since inputs are read-only and we want to modify it, we'll make a
    # copy of the metal.raw image and then mount that.
    tmp_img_metal = os.path.join(workdir, os.path.basename(img_metal))
    cp_reflink(img_metal, tmp_img_metal)
    with loop_client.device(tmp_img_metal, partscan=True) as loopdev:
        with contextlib.ExitStack() as cm:
            # So we can temporarily see the loopXpX devices
            subprocess.check_call(['mount', '-t', 'devtmpfs', 'devtmpfs', '/dev/'])
            cm.callback(subprocess.run, ['umount', '/dev/'], check=True)
            # Mount manually to avoid conflicts with osmet.
            # If mounted via the manifest, the stage begins with mounts already in place,
            # but osmet also performs a mount operation, leading to conflicts due to duplicate
            # filesystem UUIDs. Perform the manual mount only after the osmet stage
            subprocess.check_call(['mount', '-o', 'rw', loopdev + 'p4', tmp_rootfs_dir])
            cm.callback(subprocess.run, ['umount', '-R', tmp_rootfs_dir], check=True)
            subprocess.check_call(['mount', '-o', 'rw', loopdev + 'p3',
                                   os.path.join(tmp_rootfs_dir, 'boot')])
            if basearch in ['x86_64', 'aarch64']:
                subprocess.check_call(['mount', '-o', 'rw', loopdev + 'p2',
                                       os.path.join(tmp_rootfs_dir, 'boot/efi')])

            # Implements necessary CoreOS adjustments
            # including creating hardlinks in the /boot/ filesystem
            # and modifying the read-only flag in OSTree configurations
            # Where the contents of rootfs image are stored
            # Make sure to create it, if it is not created yet.

            # Remove the sysroot=readonly flag, see https://github.com/ostreedev/ostree/issues/1921
            subprocess.check_call(['sed', '-i', '/readonly=true/d', f'{tmp_rootfs_dir}/ostree/repo/config'])

            # And ensure that the kernel binary and hmac file is in the place that dracut
            # expects it to be; xref https://issues.redhat.com/browse/OCPBUGS-15843

            kernel_binary = glob.glob(f"{tmp_rootfs_dir}/boot/ostree/*/vmlinuz*")[0]
            kernel_hmac = glob.glob(f"{tmp_rootfs_dir}/boot/ostree/*/.*.hmac")[0]
            kernel_binary_basename = os.path.basename(kernel_binary)
            kernel_hmac_basename = os.path.basename(kernel_hmac)

            # Create hard links in the /boot directory
            os.link(kernel_hmac, f"{tmp_rootfs_dir}/boot/{kernel_hmac_basename}")
            os.link(kernel_binary, f"{tmp_rootfs_dir}/boot/{kernel_binary_basename}")

            print(f"Kernel binary linked: {tmp_rootfs_dir}/boot/{kernel_binary_basename}")
            print(f"Kernel HMAC linked: {tmp_rootfs_dir}/boot/{kernel_hmac_basename}")
            # Generate root squashfs/erofs
            print(f'Creating {fstype} with {fsoptions}')

            # Note the filename must be exactly "root.[squash|ero]fs"
            # because the 35coreos-live dracut module requires it.
            if fstype == "erofs":
                # Set TMPDIR='/var/tmp' to write temporary files into non-tmpfs
                # (memory backed) storage. This helps reduce memory requirements.
                # https://github.com/erofs/erofs-utils/issues/13
                subprocess.check_call(['mkfs.erofs',
                                       *fsoptions.split(' '),
                                       paths["initrd-rootfs/root.erofs"],
                                       tmp_rootfs_dir],
                                      env=dict(os.environ, TMPDIR='/var/tmp'))
            else:
                subprocess.check_call(['mksquashfs', tmp_rootfs_dir,
                                       paths["initrd-rootfs/root.squashfs"],
                                       '-root-becomes', tmp_rootfs_dir,
                                       '-wildcards', '-no-recovery',
                                       *fsoptions.split(' ')])

            # while it's mounted here, also get the kargs
            blsentry = ensure_glob(os.path.join(tmp_rootfs_dir, 'boot/loader/entries/*.conf'), n=1)[0]
            blsentry_kargs = []
            with open(blsentry, encoding='utf8') as f:
                for line in f:
                    if line.startswith('options '):
                        blsentry_kargs = line.split(' ', 1)[1].strip().split(' ')
                        break
            if len(blsentry_kargs) == 0:
                raise ValueError("found no kargs in metal image")

    return blsentry_kargs


# pylint: disable=too-many-branches
def copy_configs_and_init_kargs_json(deployed_tree, paths, blsentry_kargs, volid):
    # Filter kernel arguments for substituting into ISO bootloader
    kargs_array = [karg for karg in blsentry_kargs
                   if karg.split('=')[0] not in LIVE_EXCLUDE_KARGS]
    kargs_array.append(f"coreos.liveiso={volid}")
    kargs = ' '.join(kargs_array)
    print(f'Substituting ISO kernel arguments: {kargs}')

    kargs_json = {'files': []}
    cmdline = ''
    karg_embed_area_length = 0
    srcdir_prefix = os.path.join(deployed_tree, 'usr/share/coreos-assembler/live/')
    # Grab all the contents from the live dir from the configs. This is
    # typically just the following dir copied in to the image.
    # https://github.com/coreos/fedora-coreos-config/tree/testing-devel/live
    for srcdir, _, filenames in os.walk(srcdir_prefix):
        dir_suffix = srcdir.replace(srcdir_prefix, '', 1)
        dstdir = os.path.join(paths["iso"], dir_suffix)
        if not os.path.exists(dstdir):
            os.mkdir(dstdir)
        for filename in filenames:
            # Skip development readmes to avoid confusing users
            if filename == 'README-devel.md':
                continue
            srcfile = os.path.join(srcdir, filename)
            dstfile = os.path.join(dstdir, filename)
            # Assumes all files are text
            with open(srcfile, encoding='utf8') as fh:
                buf = fh.read()
            newbuf = buf.replace('@@KERNEL-ARGS@@', kargs)
            # if we injected kargs, also check for an embed area
            if buf != newbuf:
                karg_area_start = re.search(r'@@KERNEL-ARGS@@', buf)
                buf = newbuf
                karg_area_end = re.search(r'(#+)# COREOS_KARG_EMBED_AREA\n', buf)
                if karg_area_end is not None:
                    file_kargs = buf[karg_area_start.start():karg_area_end.start()]
                    if len(cmdline) == 0:
                        cmdline = file_kargs
                    elif cmdline != file_kargs:
                        raise ValueError(f'Default cmdline is different: "{cmdline}" != "{file_kargs}"')

                    length = karg_area_end.start() + len(karg_area_end[1]) - karg_area_start.start()
                    kargs_json['files'].append({
                        'path': os.path.join(dir_suffix, filename),
                        'offset': karg_area_start.start(),
                        'pad': '#',
                        'end': '\n',
                    })
                    if karg_embed_area_length == 0:
                        karg_embed_area_length = length
                    elif length != karg_embed_area_length:
                        raise ValueError(f"Karg embed areas of varying length {kargs_json['files']}")
            with open(dstfile, 'w', encoding='utf8') as fh:
                fh.write(buf)
            shutil.copystat(srcfile, dstfile)
            print(f'{srcfile} -> {dstfile}')

    # In the FCOS configs we have the live configs under the "EFI/fedora"
    # directory [1], but for openshift/os we have them under "EFI/vendor"
    # since we support RHEL/CentOS [2]. If this is a platform that
    # uses EFI we will rename "EFI/vendor" with the value for this platform
    # Some history on this in [3].
    #
    # [1] https://github.com/coreos/fedora-coreos-config/tree/testing-devel/live/EFI/fedora
    # [2] https://github.com/openshift/os/tree/master/live/EFI/vendor
    # [3] https://github.com/openshift/os/issues/954
    efidir = os.path.join(deployed_tree, 'usr/lib/bootupd/updates/EFI')
    if os.path.exists(efidir):
        vendor_id = find_efi_vendor_dir_name(efidir)
        grubfilepath = ensure_glob(os.path.join(paths["iso"], 'EFI/*/grub.cfg'), n=1)[0]
        srcdir = os.path.dirname(grubfilepath)
        dstdir = os.path.join(paths["iso"], f"EFI/{vendor_id}")
        if srcdir != dstdir:
            print(f"Renaming '{srcdir}' to '{dstdir}'")
            shutil.move(srcdir, dstdir)
            # And update kargs.json
            for file in kargs_json['files']:
                if file['path'] == os.path.relpath(grubfilepath, paths["iso"]):
                    file['path'] = f'EFI/{vendor_id}/grub.cfg'

    if karg_embed_area_length > 0:
        assert (karg_embed_area_length > len(cmdline))
        kargs_json.update(
            size=karg_embed_area_length,
            default=cmdline.strip(),
        )
    return kargs_json


def check_for_test_fixture(deployed_tree):
    """
    For dev/test purposes it is useful to create test fixture ISO
    images for the coreos-installer CI framework to use [1]. This test
    fixture is much smaller than an actual ISO and can be stored in git.
    Determine if the user wants a test fixture ISO created by checking
    for the coreos-installer-test-fixture file baked in the tree.
    [1] https://github.com/coreos/coreos-installer/tree/main/fixtures/iso
    """
    return os.path.exists(os.path.join(deployed_tree, 'usr/share/coreos-assembler/coreos-installer-test-fixture'))


def trim_for_test_fixtures(paths):
    """
    Replaces the large images (efiboot.img, rootfs.img, etc) with simple text files to aid in test fixture creation.
    """
    with open(paths["iso/images/efiboot.img"], 'w', encoding='utf8') as fh:
        fh.write('efiboot.img\n')
    with open(paths["iso/images/pxeboot/rootfs.img"], 'w', encoding='utf8') as fh:
        fh.write('rootfs data\n')
    with open(paths["iso/images/pxeboot/initrd.img"], 'w', encoding='utf8') as fh:
        fh.write('initrd data\n')
    with open(paths["iso/images/pxeboot/vmlinuz"], 'w', encoding='utf8') as fh:
        fh.write('the kernel\n')
    # this directory doesn't exist on s390x
    if os.path.isdir(paths["iso/isolinux"]):
        with open(os.path.join(paths["iso/isolinux"], 'isolinux.bin'), 'rb+') as fh:
            flen = fh.seek(0, 2)
            fh.truncate(0)
            fh.truncate(flen)
            fh.seek(64)
            # isohybrid checks for this magic
            fh.write(b'\xfb\xc0\x78\x70')
        for f in ensure_glob(os.path.join(paths["iso/isolinux"], '*.c32')):
            os.unlink(f)
        for f in ensure_glob(os.path.join(paths["iso/isolinux"], '*.msg')):
            os.unlink(f)


def mk_osmet_files(deployed_tree, img_metal, img_metal4k, loop_client, paths, os_release):
    """
    Add osmet files. Use a chroot here to use the same coreos-installer as is
    in the artifacts we are building. Use the deployed_tree as the chroot since
    that's the easiest thing to do.
    """
    for img, sector_size in [(img_metal, 512), (img_metal4k, 4096)]:
        with loop_client.device(img, partscan=True, read_only=True, sector_size=sector_size) as loopdev:
            img_name = os.path.basename(img)
            print(f'Generating osmet file for {img_name} image')
            img_checksum = checksum.hexdigest_file(loopdev, "sha256")
            img_osmet_file = os.path.join(paths["initrd-rootfs"], f'{img_name}.osmet')
            with Chroot(deployed_tree, bind_mounts=["/run", "/tmp"]) as chroot:
                cmd = ['coreos-installer', 'pack', 'osmet', loopdev,
                       '--description', os_release['PRETTY_NAME'],
                       '--checksum', img_checksum, '--output', img_osmet_file]
                chroot.run(cmd, check=True)


def mk_paths(workdir, fstype):
    """
    Returns a dictionary with all the paths under workdir needed throughout multiple functions in the stage.
    """
    paths = {
        "live.iso": "",
        "live.iso.minimal": "",
        "efi": "",
        "iso": "",
        "iso/coreos": "",
        "iso/coreos/features.json": "",
        "iso/coreos/igninfo.json": "",
        "iso/coreos/kargs.json": "",
        "iso/coreos/miniso.dat": "",
        "iso/images": "",
        "iso/images/cdboot.img": "",  # s390x only
        "iso/images/cdboot.prm": "",  # s390x only
        "iso/images/efiboot.img": "",  # x86_64/aarch64 only
        "iso/images/generic.prm": "",  # s390x only
        "iso/images/genericdvd.prm": "",  # s390x only
        "iso/images/initrd.addrsize": "",  # s390x only
        "iso/images/pxeboot": "",
        "iso/images/pxeboot/initrd.img": "",
        "iso/images/pxeboot/rootfs.img": "",
        "iso/images/pxeboot/vmlinuz": "",
        "iso/isolinux": "",
        "iso/zipl.prm": "",  # s390x only, deleted after use
        "initrd": "",
        "initrd/etc/coreos/features.json": "",
        "initrd/etc/coreos-live-want-rootfs": "",
        "initrd/etc/coreos-live-initramfs": "",
        "initrd-rootfs": "",
        f"initrd-rootfs/root.{fstype}": ""
    }
    for key in paths:
        paths[key] = os.path.join(workdir, key)
    return paths


def mk_workdirs(paths):
    for d in (paths["iso"],
              paths["iso/coreos"],
              paths["iso/isolinux"],
              paths["iso/images"],
              paths["iso/images/pxeboot"],
              paths["initrd"],
              paths["initrd-rootfs"]):
        os.mkdir(d)


def main(workdir, tree, inputs, options, loop_client):
    """
    Here we will generate the 4 Live/PXE CoreOS artifacts.
    There are four files created and exported from this stage.

    1. live-iso
    2. live-kernel    (i.e. images/pxeboot/vmlinuz)
    3. live-initramfs (i.e. images/pxeboot/initrd.img)
    4. live-rootfs    (i.e. images/pxeboot/rootfs.img)

    The live-iso itself contains the other 3 artifacts inside of
    it. A rough approximation of the structure looks like:

      live-iso.iso
        -> images/pxeboot/vmlinuz
        -> images/pxeboot/initrd.img
        -> images/pxeboot/rootfs.img
          -> metal.osmet
          -> metal4k.osmet
          -> root.squashfs
            -> full filesystem of metal image

    Where the ISO contains the kernel and initrd and the rootfs. The
    rootfs contains the osmet file and the root.squashfs, which itself
    contains all the files from a full CoreOS system.
    """

    img_metal, img_metal4k = parse_metal_inputs(inputs)
    # The deployed tree input is a deployment tree just as it would
    # appear on a booted OSTree system. We copy some files out of this
    # input tree since it is easier and they match what is in the metal
    # images anyway. We also use it as a chroot when we run `coreos-installer`.
    deployed_tree = inputs['deployed-tree']['path']

    # Determine some basic information about the CoreOS we are operating on.
    os_release = osrelease.parse_files(os.path.join(deployed_tree, 'etc', 'os-release'))
    version = os_release['OSTREE_VERSION']

    # Check whether live-rootfs options set
    with open(os.path.join(deployed_tree, "usr/share/coreos-assembler", "image.json"), "r", encoding="utf8") as f:
        parsed = json.load(f)
        fstype = parsed.get("live-rootfs-fstype", "squashfs")
        fsoptions = parsed.get("live-rootfs-fsoptions", "-comp zstd" if fstype == "squashfs" else "--quiet")

    paths = mk_paths(workdir, fstype)
    mk_workdirs(paths)

    # Find the kernel and initramfs. They should be the only ones on
    # the system so we'll error here if more than one are found:
    modules_dir_vmlinuz = ensure_glob(os.path.join(deployed_tree, 'usr/lib/modules/*/vmlinuz'), n=1)[0]
    modules_dir_initramfs = ensure_glob(os.path.join(deployed_tree, 'usr/lib/modules/*/initramfs.img'), n=1)[0]

    # copy those files out of the ostree into the iso root dir
    shutil.copyfile(modules_dir_vmlinuz, paths["iso/images/pxeboot/vmlinuz"])
    shutil.copyfile(modules_dir_initramfs, paths["iso/images/pxeboot/initrd.img"])

    # Generate initramfs stamp file indicating that this is a live
    # initramfs.  Store the build ID in it.
    stamppath = paths["initrd/etc/coreos-live-initramfs"]
    os.makedirs(os.path.dirname(stamppath), exist_ok=True)
    with open(stamppath, 'w', encoding='utf8') as fh:
        fh.write(version + '\n')

    # Generate rootfs stamp file with the build ID, indicating that the
    # rootfs has been appended and confirming that initramfs and rootfs are
    # from the same build.
    stamppath = os.path.join(paths["initrd-rootfs"], 'etc/coreos-live-rootfs')
    os.makedirs(os.path.dirname(stamppath), exist_ok=True)
    with open(stamppath, 'w', encoding='utf8') as fh:
        fh.write(version + '\n')

    # Generate JSON file that lists OS features available to
    # coreos-installer {iso|pxe} customize.  Put it in the initramfs for
    # pxe customize and the ISO for iso customize.
    features = json.dumps(get_os_features(tree=deployed_tree), indent=2, sort_keys=True) + '\n'
    featurespath = paths["initrd/etc/coreos/features.json"]
    os.makedirs(os.path.dirname(featurespath), exist_ok=True)
    with open(featurespath, 'w', encoding='utf8') as fh:
        fh.write(features)
    with open(paths["iso/coreos/features.json"], 'w', encoding='utf8') as fh:
        fh.write(features)

    mk_osmet_files(deployed_tree, img_metal, img_metal4k, loop_client, paths, os_release)

    blsentry_kargs = mkrootfs_metal(paths, workdir, img_metal, fstype, fsoptions, loop_client)

    # Generate rootfs image
    # The rootfs must be uncompressed because the ISO mounts root.squashfs
    # directly from the middle of the file
    extend_initramfs(initramfs=paths["iso/images/pxeboot/rootfs.img"],
                     tree=paths["initrd-rootfs"], compress=False)
    # Check that the root.[squash|ero]fs magic number is in the offset hardcoded
    # in sysroot.mount in 20live/live-generator
    offset = 124
    magic = b'hsqs'  # squashfs magic
    if fstype == "erofs":
        # The erofs's superblock starts at an absolute offset 1024 bytes
        # https://erofs.docs.kernel.org/en/latest/core_ondisk.html#superblock
        offset += 1024
        magic = bytes.fromhex("e2e1f5e0")
    with open(paths["iso/images/pxeboot/rootfs.img"], 'rb') as fh:
        fh.seek(offset)
        if fh.read(4) != magic:
            raise ValueError(f"root.{fstype} not at expected offset in rootfs image")
    # Save stream hash of rootfs for verifying out-of-band fetches
    os.makedirs(os.path.dirname(paths["initrd/etc/coreos-live-want-rootfs"]), exist_ok=True)
    make_stream_hash(paths["iso/images/pxeboot/rootfs.img"],
                     paths["initrd/etc/coreos-live-want-rootfs"])
    # Add common content
    extend_initramfs(initramfs=paths["iso/images/pxeboot/initrd.img"], tree=paths["initrd"])

    filenames = options['filenames']
    gen_live_artifacts(paths, tree, filenames, deployed_tree, loop_client, version, blsentry_kargs)


if __name__ == "__main__":
    args = osbuild.api.arguments()
    with tempfile.TemporaryDirectory(dir=args["tree"]) as tmdir:
        r = main(workdir=tmdir,
                 tree=args["tree"],
                 inputs=args["inputs"],
                 options=args["options"],
                 loop_client=remoteloop.LoopClient("/run/osbuild/api/remoteloop"))
    sys.exit(r)
