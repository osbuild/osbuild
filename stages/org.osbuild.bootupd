#!/usr/bin/python3
"""
Install GRUB on both BIOS and UEFI systems,
ensuring that your bootloader stays up-to-date.

Bootupd supports updating GRUB and shim for
UEFI firmware on x86_64 and aarch64,
and GRUB for BIOS firmware on x86_64.
The project is deployed in Fedora CoreOS and derivatives
"""

import os
import subprocess
import sys

import osbuild.api
from osbuild.util import ostree

SCHEMA_2 = r"""
"devices": {
  "type": "object",
  "additionalProperties": true
},
"mounts": {
  "type": "array"
},
"options": {
"additionalProperties": true,
"properties": {
  "static-configs": {
    "description": "Install the grub configs defined for Fedora CoreOS",
    "type": "boolean"
  },
  "bios": {
    "additionalProperties": false,
    "required": ["disk"],
    "properties": {
      "disk": {
          "description": "Disk to install GRUB for BIOS-based systems",
          "type": "string"
      }
    }
  }
}
}
"""


def main(args, options):
    static_configs = options.get("static-configs", False)
    bios = options.get("bios", {})
    disk = bios.get("disk", "")

    # Get the path where the filesystems are mounted
    mounts = args["paths"]["mounts"]

    # Get the deployment root. For non-OSTree this is simply
    # the root location of the mount points. For OSTree systems
    # we'll call ostree.deployment_path() helper to find it for us.
    deployment = mounts
    if os.path.isdir(os.path.join(mounts, "ostree")):
        deployment = ostree.deployment_path(mounts)

    bootupd_args = []
    if disk:
        # The value passed by the user is the name of the device
        # as specified in the devices array (also passed in by the
        # user). Let's map that name to the actual loopback device
        # that now backs it.
        dev = args["devices"][disk]["path"]
        bootupd_args.append(f"--device={dev}")
    if static_configs:
        bootupd_args.append("--with-static-configs")

    # We want to run the bootupctl command from the target (i.e. we
    # want to make sure the version used matches the target and not
    # risk any inconsistencies with the build root). Let's set up
    # and chroot to run the bootupctl command from the target.
    submounts = ['dev', 'proc', 'sys', 'run', 'var', 'tmp']
    for mnt in submounts:
        subprocess.run(['mount', '--rbind',
                       os.path.join("/", mnt),
                       os.path.join(deployment, mnt)],
                       check=True)
    try:
        cmd = ['chroot', deployment, '/usr/bin/bootupctl', 'backend', 'install']
        cmd.extend(bootupd_args)
        cmd.append(mounts)
        subprocess.run(cmd, check=True)
    finally:
        for mnt in submounts:
            subprocess.run(['umount', '--recursive',
                           os.path.join(deployment, mnt)],
                           check=False)

    return 0


if __name__ == '__main__':
    _args = osbuild.api.arguments()
    r = main(_args, _args["options"])
    sys.exit(r)
