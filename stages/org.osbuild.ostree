#!/usr/bin/python3

import json
import os
import sys
import subprocess

import osbuild.sources


STAGE_DESC = "Initialize the sysroot and pull and deploy an OStree commit"
STAGE_INFO = """
Initializes a clean ostree based system root, pulls the given `commit` and
creates a deployment from it using `osname` as the new stateroot (see [1]).

Since OStree internally uses a hardlink farm to create the file system tree
for the deployment from the commit data, the mountpoints for the final image
need to be supplied via the `mounts` option, as hardlinks must not span
across file systems and therefore the boundaries need to be known when doing
the deployment.

Creating a deployment also entails generating the Boot Loader Specification
entries to boot the system, which contain this the kernel command line.
The `rootfs` option can be used to indicate the root file system, containing
the sysroot and the deployments. Additional kernel options can be passed via
`kernel_opts`.

[1] https://ostree.readthedocs.io/en/latest/manual/deployment/
"""
STAGE_OPTS = """
"required": ["rootfs"],
"properties": {
  "mounts": {
    "description": "Mount points of the final file system",
    "type": "array",
    "items": {
      "description": "Description of one mount point",
      "type": "string"
    }
  },
  "kernel_opts": {
    "description": "Additional kernel command line options",
    "type": "string"
  },
  "ref": {
    "description": "OStree ref to create and use for deployment",
    "type": "string"
  },
  "rootfs": {
    "description": "Identifier to locate the root file system",
    "type": "string"
  }
}
"""


def ostree(*args, **kwargs):
    args = list(args) + [f'--{k}={v}' for k, v in kwargs.items()]
    print(f"ostree " + " ".join(args), file=sys.stderr)
    subprocess.run(["ostree"] + args,
                   encoding="utf-8",
                   stdout=sys.stderr,
                   check=True)


class MountGuard:
    def __init__(self):
        self.mounts = []

    def mount(self, source, target, bind=True, ro=False, mode="0755"):
        options = []
        if bind:
            options += ["bind"]
        if ro:
            options += ["ro"]
        if mode:
            options += [mode]

        args = ["--make-private"]
        if options:
            args += ["-o", ",".join(options)]

        subprocess.run(["mount"] + args + [source, target], check=True)
        self.mounts += [{"source": source, "target": target}]

        subprocess.run(["mount"] + args + [source, target], check=True)

    def unmount(self):

        while self.mounts:
            mount = self.mounts.pop()  # FILO: get the last mount
            target = mount["target"]
            subprocess.run(["umount", "--lazy", target],
                           check=True)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.unmount()
        return exc_type is None


def main(tree, sources, options):

    commit = options["commit"]
    osname = options["osname"]
    rootfs = options["rootfs"]
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    ref = options.get("ref", commit)

    ostree("admin", "init-fs", "--modern", tree,
           sysroot=tree)

    print(f"Fetching ostree commit {commit}")
    osbuild.sources.get("org.osbuild.ostree", [commit])

    source_repo = f"{sources}/org.osbuild.ostree/repo"

    ostree("pull-local", source_repo, commit,
           repo=f"{tree}/ostree/repo")

    if ref != commit:
        ostree("refs", "--create", ref, commit,
               repo=f"{tree}/ostree/repo")

    ostree("admin", "os-init", osname, sysroot=tree)

    kargs = []
    for opt in kopts:
        kargs += [f"--karg-append={opt}"]

    with MountGuard() as mounter:
        for mount in mounts:
            path = os.path.join(tree, mount)
            print(f"mounting {path} onto itself")
            os.makedirs(path, exist_ok=True)  # FIXME: SELinux
            mounter.mount(path, path)

        ostree("admin", "deploy", ref,
               f"--karg=root={rootfs}",
               *kargs,
               sysroot=tree,
               os=osname)


if __name__ == '__main__':
    stage_args = json.load(sys.stdin)
    r = main(stage_args["tree"],
             stage_args["sources"],
             stage_args["options"])
    sys.exit(r)
